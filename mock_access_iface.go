// Code generated by MockGen. DO NOT EDIT.
// Source: ../access_iface.go
//
// Generated by this command:
//
//	mockgen -package access -source ../access_iface.go -destination ../mock_access_iface.go
//

// Package access is a generated GoMock package.
package access

import (
	context "context"
	reflect "reflect"

	accesstypes "github.com/cccteam/ccc/accesstypes"
	validator "github.com/go-playground/validator/v10"
	gomock "go.uber.org/mock/gomock"
)

// MockAccess is a mock of Access interface.
type MockAccess struct {
	ctrl     *gomock.Controller
	recorder *MockAccessMockRecorder
	isgomock struct{}
}

// MockAccessMockRecorder is the mock recorder for MockAccess.
type MockAccessMockRecorder struct {
	mock *MockAccess
}

// NewMockAccess creates a new mock instance.
func NewMockAccess(ctrl *gomock.Controller) *MockAccess {
	mock := &MockAccess{ctrl: ctrl}
	mock.recorder = &MockAccessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccess) EXPECT() *MockAccessMockRecorder {
	return m.recorder
}

// Handlers mocks base method.
func (m *MockAccess) Handlers(validate *validator.Validate, handler LogHandler) Handlers {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handlers", validate, handler)
	ret0, _ := ret[0].(Handlers)
	return ret0
}

// Handlers indicates an expected call of Handlers.
func (mr *MockAccessMockRecorder) Handlers(validate, handler any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handlers", reflect.TypeOf((*MockAccess)(nil).Handlers), validate, handler)
}

// RequireAll mocks base method.
func (m *MockAccess) RequireAll(ctx context.Context, user accesstypes.User, domain accesstypes.Domain, permissions ...accesstypes.Permission) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, user, domain}
	for _, a := range permissions {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RequireAll", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RequireAll indicates an expected call of RequireAll.
func (mr *MockAccessMockRecorder) RequireAll(ctx, user, domain any, permissions ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, user, domain}, permissions...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RequireAll", reflect.TypeOf((*MockAccess)(nil).RequireAll), varargs...)
}

// RequireResources mocks base method.
func (m *MockAccess) RequireResources(ctx context.Context, username accesstypes.User, domain accesstypes.Domain, perm accesstypes.Permission, resources ...accesstypes.Resource) (bool, []accesstypes.Resource, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, username, domain, perm}
	for _, a := range resources {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RequireResources", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]accesstypes.Resource)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// RequireResources indicates an expected call of RequireResources.
func (mr *MockAccessMockRecorder) RequireResources(ctx, username, domain, perm any, resources ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, username, domain, perm}, resources...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RequireResources", reflect.TypeOf((*MockAccess)(nil).RequireResources), varargs...)
}

// UserManager mocks base method.
func (m *MockAccess) UserManager() UserManager {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserManager")
	ret0, _ := ret[0].(UserManager)
	return ret0
}

// UserManager indicates an expected call of UserManager.
func (mr *MockAccessMockRecorder) UserManager() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserManager", reflect.TypeOf((*MockAccess)(nil).UserManager))
}

// MockDomains is a mock of Domains interface.
type MockDomains struct {
	ctrl     *gomock.Controller
	recorder *MockDomainsMockRecorder
	isgomock struct{}
}

// MockDomainsMockRecorder is the mock recorder for MockDomains.
type MockDomainsMockRecorder struct {
	mock *MockDomains
}

// NewMockDomains creates a new mock instance.
func NewMockDomains(ctrl *gomock.Controller) *MockDomains {
	mock := &MockDomains{ctrl: ctrl}
	mock.recorder = &MockDomainsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDomains) EXPECT() *MockDomainsMockRecorder {
	return m.recorder
}

// DomainExists mocks base method.
func (m *MockDomains) DomainExists(ctx context.Context, guarantorID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DomainExists", ctx, guarantorID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DomainExists indicates an expected call of DomainExists.
func (mr *MockDomainsMockRecorder) DomainExists(ctx, guarantorID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DomainExists", reflect.TypeOf((*MockDomains)(nil).DomainExists), ctx, guarantorID)
}

// DomainIDs mocks base method.
func (m *MockDomains) DomainIDs(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DomainIDs", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DomainIDs indicates an expected call of DomainIDs.
func (mr *MockDomainsMockRecorder) DomainIDs(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DomainIDs", reflect.TypeOf((*MockDomains)(nil).DomainIDs), ctx)
}
