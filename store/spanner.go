package store

import (
	"context"

	"cloud.google.com/go/spanner"
	"github.com/google/uuid"
	"google.golang.org/api/iterator"
)

var _ Store = &SpannerStore{}

// SpannerStore implements the Store interface for Google Cloud Spanner.
type SpannerStore struct {
	client *spanner.Client
}

// NewSpannerStore creates a new SpannerStore.
func NewSpannerStore(client *spanner.Client) *SpannerStore {
	return &SpannerStore{client: client}
}

// Users
func (s *SpannerStore) CreateUser(ctx context.Context, user *User) (int64, error) {
	m := spanner.Insert("Users", []string{"Name"}, []interface{}{user.Name})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	// The user's ID is auto-generated by Spanner, so we don't have it here.
	// We'll return 0 and the caller should not rely on it.
	return 0, err
}

func (s *SpannerStore) UserByName(ctx context.Context, name string) (*User, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Users WHERE Name = @name")
	stmt.Params["name"] = name
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	row, err := iter.Next()
	if err == iterator.Done {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	var user User
	if err := row.ToStruct(&user); err != nil {
		return nil, err
	}

	return &user, nil
}

func (s *SpannerStore) DeleteUser(ctx context.Context, name string) error {
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		user, err := s.UserByName(ctx, name)
		if err != nil {
			return err
		}
		if user == nil {
			return nil // User not found, nothing to delete
		}

		m := spanner.Delete("Users", spanner.Key{user.ID})
		return txn.BufferWrite([]*spanner.Mutation{m})
	})
	return err
}

func (s *SpannerStore) ListUsers(ctx context.Context) ([]*User, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Users")
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var users []*User
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var user User
		if err := row.ToStruct(&user); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	return users, nil
}

// Roles
func (s *SpannerStore) CreateRole(ctx context.Context, role *Role) (int64, error) {
	m := spanner.Insert("Roles", []string{"Name"}, []interface{}{role.Name})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return 0, err
}

func (s *SpannerStore) RoleByName(ctx context.Context, name string) (*Role, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Roles WHERE Name = @name")
	stmt.Params["name"] = name
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	row, err := iter.Next()
	if err == iterator.Done {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	var role Role
	if err := row.ToStruct(&role); err != nil {
		return nil, err
	}

	return &role, nil
}

func (s *SpannerStore) DeleteRole(ctx context.Context, name string) error {
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		role, err := s.RoleByName(ctx, name)
		if err != nil {
			return err
		}
		if role == nil {
			return nil // Role not found, nothing to delete
		}

		m := spanner.Delete("Roles", spanner.Key{role.ID})
		return txn.BufferWrite([]*spanner.Mutation{m})
	})
	return err
}

func (s *SpannerStore) ListRoles(ctx context.Context) ([]*Role, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Roles")
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var roles []*Role
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var role Role
		if err := row.ToStruct(&role); err != nil {
			return nil, err
		}
		roles = append(roles, &role)
	}

	return roles, nil
}

func (s *SpannerStore) ListRoleUsers(ctx context.Context, roleID int64, domain string) ([]*User, error) {
	stmt := spanner.NewStatement(`
		SELECT u.Id, u.Name
		FROM Users u
		JOIN UserRoleMaps ur ON ur.UserId = u.Id
		WHERE ur.RoleId = @roleId AND ur.Domain = @domain
	`)
	stmt.Params["roleId"] = roleID
	stmt.Params["domain"] = domain

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var users []*User
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var user User
		if err := row.ToStruct(&user); err != nil {
			return nil, err
		}
		users = append(users, &user)
	}

	return users, nil
}

func (s *SpannerStore) ListUserRoles(ctx context.Context, userID int64, domain string) ([]*Role, error) {
	stmt := spanner.NewStatement(`
		SELECT r.Id, r.Name
		FROM Roles r
		JOIN UserRoleMaps ur ON ur.RoleId = r.Id
		WHERE ur.UserId = @userId AND ur.Domain = @domain
	`)
	stmt.Params["userId"] = userID
	stmt.Params["domain"] = domain

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var roles []*Role
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var role Role
		if err := row.ToStruct(&role); err != nil {
			return nil, err
		}
		roles = append(roles, &role)
	}

	return roles, nil
}

// Permissions
func (s *SpannerStore) CreatePermission(ctx context.Context, permission *Permission) (int64, error) {
	m := spanner.Insert("Permissions", []string{"Name"}, []interface{}{permission.Name})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return 0, err
}

func (s *SpannerStore) PermissionByName(ctx context.Context, name string) (*Permission, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Permissions WHERE Name = @name")
	stmt.Params["name"] = name
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	row, err := iter.Next()
	if err == iterator.Done {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	var perm Permission
	if err := row.ToStruct(&perm); err != nil {
		return nil, err
	}

	return &perm, nil
}

func (s *SpannerStore) DeletePermission(ctx context.Context, name string) error {
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		permission, err := s.PermissionByName(ctx, name)
		if err != nil {
			return err
		}
		if permission == nil {
			return nil // Permission not found, nothing to delete
		}

		m := spanner.Delete("Permissions", spanner.Key{permission.ID})
		return txn.BufferWrite([]*spanner.Mutation{m})
	})
	return err
}

func (s *SpannerStore) ListRolePermissions(ctx context.Context, roleID int64, domain string) ([]*Permission, error) {
	stmt := spanner.NewStatement(`
		SELECT p.Id, p.Name
		FROM Permissions p
		JOIN PermissionResourceMaps prm ON prm.PermissionId = p.Id
		JOIN RolePermissionResourceMaps rprm ON rprm.PermissionResourceMapId = prm.Id
		WHERE rprm.RoleId = @roleId
	`)
	stmt.Params["roleId"] = roleID

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var permissions []*Permission
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var perm Permission
		if err := row.ToStruct(&perm); err != nil {
			return nil, err
		}
		permissions = append(permissions, &perm)
	}

	return permissions, nil
}

func (s *SpannerStore) ListUserPermissions(ctx context.Context, userID int64, domain string) ([]*Permission, error) {
	stmt := spanner.NewStatement(`
		SELECT p.Id, p.Name
		FROM Permissions p
		JOIN PermissionResourceMaps prm ON prm.PermissionId = p.Id
		JOIN RolePermissionResourceMaps rprm ON rprm.PermissionResourceMapId = prm.Id
		JOIN UserRoleMaps ur ON ur.RoleId = rprm.RoleId
		WHERE ur.UserId = @userId AND ur.Domain = @domain
	`)
	stmt.Params["userId"] = userID
	stmt.Params["domain"] = domain

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var permissions []*Permission
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var perm Permission
		if err := row.ToStruct(&perm); err != nil {
			return nil, err
		}
		permissions = append(permissions, &perm)
	}

	return permissions, nil
}

// Resources
func (s *SpannerStore) CreateResource(ctx context.Context, resource *Resource) (int64, error) {
	m := spanner.Insert("Resources", []string{"Name"}, []interface{}{resource.Name})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return 0, err
}

func (s *SpannerStore) ResourceByName(ctx context.Context, name string) (*Resource, error) {
	stmt := spanner.NewStatement("SELECT Id, Name FROM Resources WHERE Name = @name")
	stmt.Params["name"] = name
	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	row, err := iter.Next()
	if err == iterator.Done {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	var res Resource
	if err := row.ToStruct(&res); err != nil {
		return nil, err
	}

	return &res, nil
}

func (s *SpannerStore) DeleteResource(ctx context.Context, name string) error {
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		resource, err := s.ResourceByName(ctx, name)
		if err != nil {
			return err
		}
		if resource == nil {
			return nil // Resource not found, nothing to delete
		}

		m := spanner.Delete("Resources", spanner.Key{resource.ID})
		return txn.BufferWrite([]*spanner.Mutation{m})
	})
	return err
}

func (s *SpannerStore) ListRolePermissionResources(ctx context.Context, roleID, permissionID int64, domain string) ([]*Resource, error) {
	stmt := spanner.NewStatement(`
		SELECT r.Id, r.Name
		FROM Resources r
		JOIN PermissionResourceMaps prm ON prm.ResourceId = r.Id
		JOIN RolePermissionResourceMaps rprm ON rprm.PermissionResourceMapId = prm.Id
		WHERE rprm.RoleId = @roleId AND prm.PermissionId = @permissionId
	`)
	stmt.Params["roleId"] = roleID
	stmt.Params["permissionId"] = permissionID

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var resources []*Resource
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var res Resource
		if err := row.ToStruct(&res); err != nil {
			return nil, err
		}
		resources = append(resources, &res)
	}

	return resources, nil
}

func (s *SpannerStore) ListUserPermissionResources(ctx context.Context, userID, permissionID int64, domain string) ([]*Resource, error) {
	stmt := spanner.NewStatement(`
		SELECT r.Id, r.Name
		FROM Resources r
		JOIN PermissionResourceMaps prm ON prm.ResourceId = r.Id
		JOIN RolePermissionResourceMaps rprm ON rprm.PermissionResourceMapId = prm.Id
		JOIN UserRoleMaps ur ON ur.RoleId = rprm.RoleId
		WHERE ur.UserId = @userId AND prm.PermissionId = @permissionId AND ur.Domain = @domain
	`)
	stmt.Params["userId"] = userID
	stmt.Params["permissionId"] = permissionID
	stmt.Params["domain"] = domain

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	var resources []*Resource
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, err
		}

		var res Resource
		if err := row.ToStruct(&res); err != nil {
			return nil, err
		}
		resources = append(resources, &res)
	}

	return resources, nil
}

// Mappings
func (s *SpannerStore) CreateUserRoleMap(ctx context.Context, userID, roleID int64, domain string) error {
	m := spanner.Insert("UserRoleMaps", []string{"UserId", "RoleId", "Domain"}, []interface{}{userID, roleID, domain})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return err
}

func (s *SpannerStore) DeleteUserRoleMap(ctx context.Context, userID, roleID int64, domain string) error {
	m := spanner.Delete("UserRoleMaps", spanner.Key{userID, roleID, domain})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return err
}

func (s *SpannerStore) CreatePermissionResourceMap(ctx context.Context, permissionID, resourceID int64) (int64, error) {
	var id int64
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		stmt := spanner.NewStatement("SELECT Id FROM PermissionResourceMaps WHERE PermissionId = @permissionId AND ResourceId = @resourceId")
		stmt.Params["permissionId"] = permissionID
		stmt.Params["resourceId"] = resourceID
		iter := txn.Query(ctx, stmt)
		defer iter.Stop()

		row, err := iter.Next()
		if err == iterator.Done {
			id = int64(uuid.New().ID())
			m := spanner.Insert("PermissionResourceMaps", []string{"Id", "PermissionId", "ResourceId"}, []interface{}{id, permissionID, resourceID})
			return txn.BufferWrite([]*spanner.Mutation{m})
		}
		if err != nil {
			return err
		}

		return row.Column(0, &id)
	})
	return id, err
}

func (s *SpannerStore) CreateRoleMap(ctx context.Context, roleID, permResID int64) (int64, error) {
	var id int64
	_, err := s.client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {
		stmt := spanner.NewStatement("SELECT Id FROM RolePermissionResourceMaps WHERE RoleId = @roleId AND PermissionResourceMapId = @permResId")
		stmt.Params["roleId"] = roleID
		stmt.Params["permResId"] = permResID
		iter := txn.Query(ctx, stmt)
		defer iter.Stop()

		row, err := iter.Next()
		if err == iterator.Done {
			id = int64(uuid.New().ID())
			m := spanner.Insert("RolePermissionResourceMaps", []string{"Id", "RoleId", "PermissionResourceMapId"}, []interface{}{id, roleID, permResID})
			return txn.BufferWrite([]*spanner.Mutation{m})
		}
		if err != nil {
			return err
		}

		return row.Column(0, &id)
	})
	return id, err
}

func (s *SpannerStore) DeleteRolePermissionMap(ctx context.Context, roleID, permResID int64) error {
	m := spanner.Delete("RolePermissionResourceMaps", spanner.Key{roleID, permResID})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return err
}

// Conditions
func (s *SpannerStore) CreateCondition(ctx context.Context, roleMapID int64, condition string) error {
	m := spanner.Insert("Conditions", []string{"RoleMapId", "Condition"}, []interface{}{roleMapID, condition})
	_, err := s.client.Apply(ctx, []*spanner.Mutation{m})
	return err
}

// Query
func (s *SpannerStore) CheckPermission(ctx context.Context, user, domain, resource, permission string) (bool, string, error) {
	stmt := spanner.NewStatement(`
		SELECT
			rm.Id, c.Condition
		FROM Users u
		JOIN UserRoleMaps ur ON ur.UserId = u.Id
		JOIN Roles r ON r.Id = ur.RoleId
		JOIN RolePermissionResourceMaps rm ON rm.RoleId = r.Id
		JOIN PermissionResourceMaps prm ON prm.Id = rm.PermissionResourceMapId
		JOIN Resources res ON res.Id = prm.ResourceId
		JOIN Permissions p ON p.Id = prm.PermissionId
		LEFT JOIN Conditions c ON c.RolePermissionResourceMapId = rm.Id
		WHERE u.Name = @user AND
			ur.Domain = @domain AND
			res.Name = @resource AND
			p.Name = @permission
	`)
	stmt.Params["user"] = user
	stmt.Params["domain"] = domain
	stmt.Params["resource"] = resource
	stmt.Params["permission"] = permission

	iter := s.client.Single().Query(ctx, stmt)
	defer iter.Stop()

	row, err := iter.Next()
	if err == iterator.Done {
		return false, "", nil
	}
	if err != nil {
		return false, "", err
	}

	var roleMapID int64
	var condition spanner.NullString
	if err := row.Columns(&roleMapID, &condition); err != nil {
		return false, "", err
	}

	return true, condition.String(), nil
}